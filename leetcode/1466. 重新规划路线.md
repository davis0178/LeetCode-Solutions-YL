```python
class Solution:
    def minReorder(self, n: int, connections: List[List[int]]) -> int:
        # 构建无向图：消除方向，节点互通
        g = [[] for _ in range(n)]
        for a, b in connections:
            g[a].append((b, 1)) # 原始方向，赋予 cost 1
            g[b].append((a, 0)) # 反向方向
        
        ans = 0
        seen = [False] * n # 同理的做法
        seen[0] = True

        def dfs(i: int) -> None:
            nonlocal ans
            for j, cost in g[i]:
                if not seen[j]: # 子节点未到达
                    seen[j] = True # 那就到达
                    # 原始方向就是父到子，cost + 1
                    # 原始方向是子到父，cost + 0
                    ans += cost
                    dfs(j)
        
        dfs(0) # 从 0 开始
        return ans
```

这里要构建的是无向图，但凭借“是否背离 0”做区分：对树的任意节点 x，到 0 的无向路径唯一。因此想要满足任意节点能沿有向边走到 0 的题意，就要求这条路径上每条边的方向都朝向 0。因此一旦有路径是背离 0 的则需要翻转一次。有向图化为无向图之后，相当于节点都是互通的了，但是赋予原始方向一个 cost 1。

在 dfs 过程中，从 0 开始，将会由父节点走向子节点。如果父到子是原始方向，那么就需要翻转，记 1 cost。如果原始方向是子到父，那么没有 cost。

#深度优先搜索 #广度优先搜索 #图