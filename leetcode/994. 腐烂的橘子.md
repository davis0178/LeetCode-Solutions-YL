```python
class Solution:
    def orangesRotting(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        fresh = 0
        q = []

        for i, row in enumerate(grid):
            for j, x in enumerate(row):
                if grid[i][j] == 1:
                    fresh += 1
                elif grid[i][j] == 2:
                    q.append((i, j))
        
        ans = 0
        while fresh and q:
            ans += 1
            tmp = q
            q = []
            for x, y in tmp:
                for i, j in (x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1):
                    if 0 <= i < m and 0 <= j < n and grid[i][j] == 1:
                        grid[i][j] = 2
                        fresh -= 1
                        q.append((i, j))
        
        return -1 if fresh else ans
```

第一步：统计好橘子和烂橘子，好橘子统计数量，烂橘子的位置加入 q
第二步：进入循环。循环结束条件是没有好橘子了或没有未结算的坏橘子（结算后的坏橘子不再进入考虑范围，因此循环每次都重置 q）
第三步：每次循环开始先答案 ans 加一。遍历**未结算的坏橘子**，在这些坏橘子的四个方向上（前两句意味着一个双重循环），如果是好橘子，就变坏，更新好橘子数量，更新下一轮的坏橘子
第四步：最终退出循环，如果还有好橘子，说明永远不可能烂完。否则确实烂完了，返回烂掉的步数

#广度优先搜索 #数组 #矩阵