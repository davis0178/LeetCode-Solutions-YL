```python
class Solution:
    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
        candidates.sort()
        ans = []
        path = []

        def dfs(i: int, left: int) -> None:
            if left == 0:
                ans.append(path.copy())
                return
            
            if i == len(candidates) or left < candidates[i]:
                return
            
            dfs(i + 1, left)

            path.append(candidates[i])
            dfs(i, left - candidates[i]) # 选了 i 也不用加一，因为这里同一个数字可以无限重复选
            path.pop()

        dfs(0, target)
        return ans
```
从一个数组中找出一些数总和等于一个值，那就是找出一个**子集**，子集就是选与不选，还要加入一个剩余凑成 target 的一个值，用于控制该不该加入答案
这里在选或不选法中还加入了一个剪枝：先把数组按非递减顺序排列，当当前数字就大于 left 时，不可能凑齐 target。也不用往后面找了，直接都 return

```python
class Solution:
    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
        candidates.sort()
        ans = []
        path = []

        def dfs(i: int, left: int) -> None:
            if left == 0:
                ans.append(path.copy())
                return # 不用继续去枚举了，因为一定大于 target
            
            # 枚举选哪个
            for j in range(i, len(candidates)):
	            #剪枝在这里：排序后，当当前遍历的元素大于left时，后面的数都太大了
                if candidates[j] > left:
                    break
                path.append(candidates[j])
                dfs(j, left - candidates[j]) # 不用加一，可以无限重复选
                path.pop() # 记得回溯
        
        dfs(0, target)
        return ans
```



#数组 #回溯