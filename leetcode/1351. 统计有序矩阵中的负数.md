```python
class Solution:
    def countNegatives(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        ans = 0

        for i in range(m):
            for j in range(n):
                if grid[i][j] < 0:
                    ans += 1
        
        return ans
```

暴力法，没什么好说的
时间复杂度：O(mn) 空间复杂度：O(1)

如何使用二分查找降低时间复杂度？如下：

```python
class Solution:
    def countNegatives(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        ans = 0
        i, j = 0, n - 1
        while i < m and j >= 0: # 还有剩余元素
            if grid[i][j] < 0:
                ans += m - i # 这一列的长度
                j -= 1
            else:
                i += 1
        return ans
```

利用矩阵**行列有序**的特征（非严格递减顺序）从矩阵的**右上角**找起。
如果右上角小于 0，那么对应那一**列**都会小于 0。将这一列剩余元素加入答案
如果右上角非负，那么对应那一**行**都会非负。排除那一行

#数组 #二分查找 #矩阵