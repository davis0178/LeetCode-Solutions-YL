**on_path 写法：**
```python
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        n = len(nums)
        path = [0] * n # 定长的
        on_path = [False] * n # 使用 on_path 确定剩余未选数字的集合 s
        ans = []

        def dfs(i: int) -> None:
            if i == n:
                ans.append(path.copy())
                return
            for j, on in enumerate(on_path):
                if not on: # 没被选过才能被选
                    path[i] = nums[j]
                    on_path[j] = True
                    dfs(i + 1)
                    on_path[j] = False

        dfs(0)
        return ans
```

数组 path 记录路径上的数（已选数字）
集合 s 记录剩余未选数字
回溯三问：
1. **当前操作？** 从 s 中枚举 `path[i]` 要填入的数字（剩余未选数字）
2. **子问题？** 构造排列 ≥ i 的部分（下一个 path），剩余未选数字集合为 s
3. **下一个子问题？** 构造排列 大于等于 i + 1 的部分，剩余未选数字集合为 s - {x}

**集合减法写法：**
```python
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        n = len(nums)
        ans = []
        path = [0] * n
        def dfs(i, s):
	        if i == n:
		        ans.append(path.copy())
		        return
		    for x in s:
			    path[i] = x
			    dfs(i + 1, s - {x})
		dfs(0, set(nums))
		return ans
```
⬆️使用集合减法语法更简洁

#数组 #回溯