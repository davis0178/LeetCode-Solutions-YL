**做法一：选或不选（输入的视角）**
```python
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        ans = []
        path = []
        n = len(nums)

        def dfs(i: int) -> None:
            if i == n:
                ans.append(path.copy())
                return
            
            dfs(i + 1)

            path.append(nums[i])
            dfs(i + 1)
            path.pop()
        
        dfs(0)
        return ans
```
子集就不需要定长 path 了
然后对于输入的每一位 nums，都是选与不选
记得回溯恢复现场，因为对后面的递归而言，前面的递归残留是多余的

做法二：枚举选哪个（答案的视角）
```python
class Solution:
	def subsets(self, nums: List[int]) -> List[List[int]]:
		ans = []
		path = []
		n = len(nums)
		
		# 枚举 nums 中选谁加到 path
		def dfs(i: int) -> None:
			ans.append(path.copy()) # 不选，直接加入答案
			for j in range(i, n): # 选，枚举选择的数字
				path.append(nums[j])
				dfs(j + 1) # 选 j，意味着 i 到 j - 1 都不选
				path.pop()
		
		dfs(0)
		return ans
```

#位运算 #数组 #回溯