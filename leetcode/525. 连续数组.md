```python
class Solution:
    def findMaxLength(self, nums: List[int]) -> int:
        delta = 0
        ans = 0
        d = defaultdict(int)
        d[0] = -1

        for i, x in enumerate(nums):
            delta += 1 if x == 1 else -1

            if delta in d:
                ans = max(ans, i - d[delta])
            else:
                d[delta] = i
        
        return ans
```

想象有一个 delta，遇见 0 则减一，而遇见 1 就加一。
那么 delta 为 0 时这个下标之前的子数组拥有同等数量的 0 和 1 -> 当两个下标之间 delta 相等时，这两个下标构成的子数组拥有同等数量的 0 和 1。
将 0 和 1 数量相等的问题转化为前缀和问题，使用哈希表存储 delta 值出现的位置（初始化需要 d[0] = -1，相当于没出现子数组时 delta 也是 0，这里下标的位置是-1），当找到同等 delta，则更新答案（此时不用更新这个 delta 值出现的位置，因为显然两个下标越远越好）

#数组 #双指针 #排序