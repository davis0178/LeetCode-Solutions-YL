```python
class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        q = deque()
        ans = []

        for i, x in enumerate(nums):
            while q and nums[q[-1]] <= x:
                q.pop()
            
            q.append(i)

            if q[0] < i - k + 1:
                q.popleft()
            
            if i >= k - 1:
                ans.append(nums[q[0]])
        
        return ans
```

滑窗只在窗口的扩展/收缩使目标函数**单调变化**才可用
但这里**最大值不是单调的**
因此必须记住**候选最大值的历史结构**，引出==单调队列==

==解法：==
Step 1: 弹尾
维护队列 `q` 存下标，**队头永远是当前窗口最大值**
新元素 `nums[i]` 会取代掉所有更小且更早过期的先前元素 `nums[q[-1]]`
这样就维护了单调性
我们可以放心地把当前元素入队

Step 2: 弹头
如果窗口左端越界 `q[0] < i - k + 1`，说明这个最大值已经不在窗口里了，进行 `popleft()`
*老员工的能力周期 `q[0]` 跟不上时代 `i - k + 1`*

Step 3: 更新答案
如果单调队列是完整的`i >= k - 1`，就记录答案
*完整的队列（长度为 k）需要索引到 k - 1*

时间复杂度是 `O(n)`，因为每个元素最多入队一次、最多出队一次

#队列 #数组 #滑动窗口 #单调队列 #堆（优先队列）