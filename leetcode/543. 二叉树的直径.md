```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:
        ans = 0
        def dfs(node: Optional[TreeNode]) -> int:
            if node is None:
                return -1
            l = dfs(node.left) + 1
            r = dfs(node.right) + 1
            nonlocal ans
            ans = max(ans, l + r)
            return max(l, r)
        dfs(root)
        return ans
```

链：空节点的链长是 -1，叶子节点的链长是 0（只有圆饼没有斜杠）
直径：直径可以拐弯，**不一定经过树根 root**（换句话说，深度一定经过root）。因此枚举每个 node 时，计算左右两条链值之和，取更新答案的最大值。

dfs 返回的不是直径的长度，因为直径不能与上面其他的链继续拼接

#树 #深度优先搜索 #二叉树
