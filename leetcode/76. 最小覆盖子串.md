```python
class Solution:
    def minWindow(self, s: str, t: str) -> str:
        cnt_s, cnt_t = Counter(), Counter(t)
        left = 0
        ans_left, ans_right = -1, len(s)

        for right, c in enumerate(s):
            cnt_s[c] += 1
            while cnt_s >= cnt_t:
                if right - left < ans_right - ans_left:
                    ans_left, ans_right = left, right
                cnt_s[s[left]] -= 1
                left += 1
        
        return "" if ans_left < 0 else s[ans_left: ans_right + 1]
```

 s 的子串涵盖 t，则维护 s 子串（使用滑窗实现）的 Counter **cnt_s**，与 t 的 Counter **cnt_t**进行比较。涵盖 -> **cnt_s >= cnt_t**
 因为要找到**最小**子串，我们在**合法时**应尝试**收缩**滑窗，在收缩阶段更新答案（而不是非法时收缩滑窗，收缩结束才更新答案）
 维护 ans_left 和 ans_right，初始化为非法值（ans_left = -1, ans_right = n），若这两个值从未更新，则未找到最小覆盖子串，返回 ""。找到则字符串切片

2025.12.26: 更新答案的条件是当前子串长度比答案子串**长度**更小。因此比较 right - left 和 ans_right - ans_left

#哈希表 #字符串 #滑动窗口