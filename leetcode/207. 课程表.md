```python
class Solution:
    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:
        # 建图
        g = [[] for _ in range(numCourses)] # 一共 n 个课程就是 n 个空
        for a, b in prerequisites:
            g[b].append(a) # 索引为 b 的空能够通向 a（b 指到 a）
        
        # 颜色数组，0 表示未访问，1 表示正在访问，2 表示访问完毕
        colors = [0] * numCourses # 初始化未访问
        
        def dfs(x: int) -> bool:
            colors[x] = 1 # 访问中
            for y in g[x]:
                # 情况一：colors[y] == 1，表示找到了环
                # 情况二：colors[y] == 0，未知，继续递归 y 找信息
                # 情况三：colors[y] == 2，继续递归也只是重蹈覆辙，不用递归了
                if colors[y] == 1 or colors[y] == 0 and dfs(y):
                    return True
            colors[x] = 2 # 访问完毕
            return False # 没有找到环
        
        for i, c in enumerate(colors):
            if c == 0 and dfs(i):
                return False
        return True
```
DFS 三色标记法：核心问题是判断图中是否有环
第一步：建图，把握有几门课程就是有几个坑位，一个坑位实际表现为数组索引对应的列表，列表中放这门课程能够“去”的课程（这门课程是哪些课程的先修课程）
第二步：创建颜色数组，0 表示未访问，1 表示正在访问，2 表示访问完毕
第三部：dfs，先标记为 1，正在访问，遍历每门课程的网上邻居，注意有三种情况，在找到环时返回 True。如果没有找到环，先将该门课程标记为 2，再返回 False
第四步：遍历颜色数组，未访问则发起 dfs，找到环返回 False（这课没法上了），否则返回 True


#深度优先搜索 #广度优先搜索 #图 #拓扑排序