```python
class Solution:
    def characterReplacement(self, s: str, k: int) -> int:
        cnt = defaultdict(int)
        left = 0
        max_freq = 0
        ans = 0

        for right, c in enumerate(s):
            cnt[c] += 1
            max_freq = max(max_freq, cnt[c])

            while (right - left + 1) - k > max_freq:
                cnt[s[left]] -= 1
                left += 1
            
            ans = max(ans, right - left + 1)
        
        return ans
```

记录窗口内出现次数最多的字符的出现次数 max_freq
我们将滑窗中其他内容替换为滑窗中出现次数最多的字符，才有可能构成更长的包含相同字母的最长子字符串
所以滑窗非法条件：滑窗长度 L - max_freq > k，要替换成出现次数最多的字符的其他内容太多了，尝试缩小左边界减少内容

这里有一个小点，那就是 while 内部循环虽然可能改变 max_freq，但其实不需要去额外维护 max_freq。因为 max_freq 单调不减，left 只在 窗口长度 - max_freq > k 时右移，这保证了任意时刻的 ans 都不超过“某个时刻存在过的、同一个 right 为结尾的可行窗口长度上界”。因此 ans 不会偏大
**后续窗口长度其实不会超过产生虚假 max_freq 时的可行窗口长度**

#哈希表 #字符串 #滑动窗口