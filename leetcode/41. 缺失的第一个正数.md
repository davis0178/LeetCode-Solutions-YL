```python
class Solution:
    def firstMissingPositive(self, nums: List[int]) -> int:
        n = len(nums)

        for i in range(n):
            while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]:
                j = nums[i] - 1
                nums[i], nums[j] = nums[j], nums[i]
        
        for i in range(n):
            if nums[i] != i + 1:
                return i + 1
        
        return n + 1
```

这道题要求 O(n) 时间 + O(1) 额外空间

---
==解法==：
Step 1:
把每个值 x (若满足正整数 1 <= x <= n) 放在下标 x - 1 的位置上（它**应该在的位置**）（构成一个**人为的哈希表**）（最终满足 `nums[i] = i + 1`）

while 的意义是“**不断**把当前位置上的数送到它该在的位置”。如果当前位置不再是正整数，那么它不会影响答案。如果当前位置已经是 index + 1，就归位而不用动了。

执行完 step1，所有能够被归位的正整数都归位了。不能被归位的正整数和负数不会影响答案

Step 2:
再遍历一遍数组，第一个**不满足** `nums[i] == i + 1` 的数就是答案（错位了）
如果 1, 2, ..., n 全部出现，那么最小缺失正整数就是 n + 1

如果都满足，答案就是 n + 1

因为数组可以重复，所以完成 step1 后能够保证第一个错位的数比它小的数都已经归位了。所以这个第一个错位的数其索引映射到第一个缺失的正整数

---

2025.12.27: 这有一个小细节，判断是否归位正确的条件不能是 `nums[i] != i + 1`，因为如果测试用例是 `[1, 1]` 那不就炸了吗如果条件这样写只能判定当前位置上的数是不是被正确归位的，这样两个 1 就会不断交换。正确判定是 `nums[i] != nums[nums[i] - 1]`，是“**要交换的目标位置上有没有该有的值**”这样就不会一直交换一个值

#数组 #哈希表

