**1. 割或不割**
```python
class Solution:
    def partition(self, s: str) -> List[List[str]]:
        n = len(s)
        ans = []
        path = []
		
		# 考虑的是位置 i 后面的分割位，该不该分割
		# start 是当前回文子串的开始位置
        def dfs(i: int, start: int) -> None:
            if i == n: # 分割完毕
                ans.append(path.copy())
                return
            
            # 不分割
            if i < n - 1: # 当 i == n - 1，只能分割
                dfs(i + 1, start)
            
            # 分割
            t = s[start: i + 1]
            if t == t[::-1]: # 判断回文
                path.append(t)
                dfs(i + 1, i + 1) # 分割后更新 start 从 i + 1 开始
                path.pop() # 记得回溯
        
        dfs(0, 0)
        return ans
```
从每个索引位置到每个分割位，那就是每个索引之后的空隙（i + 1）
dfs 中写不分割或者分割

**2. 枚举子串结束位置**
```python
class Solution:
    def partition(self, s: str) -> List[List[str]]:
        n = len(s)
        ans = []
        path = []

        def dfs(i: int) -> None:
            if i == n:
                ans.append(path.copy())
                return
            for j in range(i, n): # 枚举子串的结束位置
                t = s[i: j + 1]
                if t == t[::-1]: # 是回文串就 append
                    path.append(t)
                    dfs(j + 1) # 考虑剩余的 s[j + 1:] 怎么分割
                    path.pop() # 记得回溯
        
        dfs(0)
        return ans
```

#字符串 #动态规划 #回溯