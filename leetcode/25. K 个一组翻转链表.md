```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:
        # 统计链表数量
        n = 0
        cur = head
        while cur:
            n += 1
            cur = cur.next

        # 设置节点
        p0 = dummy = ListNode(next=head)
        cur = head

        # 开始反转
        while n >= k:
            n -= k
		
        # 1. 组内反转
	        pre = None
            for _ in range(k):
                nxt = cur.next
                cur.next = pre
                pre = cur
                cur = nxt

        # 2. 组间反转
            tail = p0.next # 反转前的头，反转后变成尾
            p0.next = pre # pre 是反转后的头
            tail.next = cur # cur 是下一段的起点
            p0 = tail # p0 移动到已处理部分的末尾
        
        return dummy.next
```

这道题的难点在于组间如何反转链表。
当一个循环中数量为 k 的一组翻转成功，那么这一组之前一个节点（p0）的下一个节点就是这一组的最后一个节点（tail）。想象反转链表中的 pre 和 cur，pre 就是反转后链表的第一个节点，将 p0 连到 pre。
再将 tail 连到 cur，设置新的 p0 为 tail

#递归 #链表