```python
class Solution:
    def trap(self, height: List[int]) -> int:
        n = len(height)
        left, right = 0, n - 1
        leftMax = rightMax = 0
        ans = 0

        while left < right:
            leftMax = max(leftMax, height[left])
            rightMax = max(rightMax, height[right])

            if height[left] <= height[right]:
                ans += leftMax - height[left]
                left += 1
            else:
                ans += rightMax - height[right]
                right -= 1
        
        return ans
```

**维护左右的历史最高，更新高度更矮的一侧**

考虑 [5, 0, 0, 0, 0, 1] 这个例子，双指针的移动逻辑会优先更新高度更矮的那一侧，所以 left 会一直在 index = 0，导致 5 最后才更新。
因此，算法选择更新较矮一侧时，另一侧的历史最高不会成为限制当前水位的瓶颈。因此当前水位由当前侧历史最高决定
（本质比较的是 leftMax 和 rightMax，每次结算较小者那一侧。直到这个最大值被抢夺，才改换更新另一侧）
[5, 0, 0, 6, 0, 1]

并不会出现 left = 1, right = 5 的情况

#栈 #数组 #双指针 #动态规划 #单调栈
