```python
class LRUCache:

    def __init__(self, capacity: int):
        self.capacity = capacity
        self.cache = OrderedDict() # 双向链表

    def get(self, key: int) -> int:
        if key not in self.cache:
            return -1
        self.cache.move_to_end(key, last = False) # 移到双向链表头（左）
        return self.cache[key]

    def put(self, key: int, value: int) -> None:
        self.cache[key] = value
        self.cache.move_to_end(key, last = False)
        if len(self.cache) > self.capacity:
            self.cache.popitem() # 爆掉最右的（最久未使用）


# Your LRUCache object will be instantiated and called as such:
# obj = LRUCache(capacity)
# param_1 = obj.get(key)
# obj.put(key,value)
```

**LRU 缓存**：Least Recently Used 最近最少使用。是常用的页面置换算法，选择最近最久未使用的页面予以淘汰。该算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 t，当须淘汰一个页面时，选择现有页面中其 t 值最大的，即最近最少使用的页面予以淘汰

题目要求 get 和 put 都是 O(1) 时间复杂度，因此用**双向链表**（OrderedDict）实现

get: 把一本书（key）抽出来，放在最上面
put: 放入一本新书，如果有这本书视为get，加上替换它的value
move_to_end 本来是移向链表尾（右），last = False 就反转到链表头
**最久未使用 -> 处于链表尾**，当页面数量大于 capacity，就爆掉链表尾的

#设计 #哈希表 #链表 #双向链表
