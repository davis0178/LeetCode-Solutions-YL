**1. 选或不选：**
```python
class Solution:
    def generateParenthesis(self, n: int) -> List[str]:
        ans = []
        path = [''] * (n * 2)

        def dfs(left: int, right: int) -> None:
            if right == n:
                ans.append(''.join(path))
                return
            if left < n:
                path[left + right] = '('
                dfs(left + 1, right)
            if right < left:
                path[left + right] = ')'
                dfs(left, right + 1)
        
        dfs(0, 0)
        return ans
```
本质上是在 2n 个位置中选出 n 个填左括号、剩下 n 个填右括号。因此，可以把“选”视作填左括号，“不选”视作填右括号（==填左括号或者填右括号==）
但有额外约束：过程中保证右括号的个数小于等于左括号的个数。这样才能括起来。
定长 path 就不需要回溯
其他细节：left + right 确定 path 当前的位置，当前填了 left 个左括号，当前填了 right 个右括号

**2. 枚举下一个左括号的位置：**
```python
class Solution:
    def generateParenthesis(self, n: int) -> List[str]:
        ans = []
        path = [] # 记录左括号的下标
		
		# 目前填了 i 个括号，左右括号之差为 balance
        def dfs(i: int, balance: int) -> None:
            if len(path) == n:
                s = [')'] * (n * 2) # 等长数组
                # 改成左括号
                for j in path:
                    s[j] = '('
                ans.append(''.join(s))
                return
            
            # 枚举右括号的位置：
            for right in range(balance + 1):
                path.append(i + right) # 填入 right 个右括号，再填入 1 个左括号
                dfs(i + right + 1, balance - right + 1)
                path.pop()
        
        dfs(0, 0)
        return ans
```
当前面填了 5 个左括号、2 个右括号，还能填几个右括号？还能填 3 个。因此，枚举在填下一个左括号前填了 0, 1, 2, 3 个右括号的情况，就能够得到下一个左括号的位置
balance 表示左右括号之差，枚举 `range(balance + 1)`
因为 path 里都是左括号的下标，在填满括号更新答案时，我们生成一个全是右括号的等长数组，遍历 path 中的位置，把对应位置改成左括号，再加入答案中

#字符串 #动态规划 #回溯